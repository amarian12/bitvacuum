#!/usr/bin/env ruby
require 'gli'
require 'yaml'
require 'bitcoin'
require_relative 'configuration'

include GLI::App

program_desc 'BitVacuum is an application that is intended to clean dust (small transactions) out of the XCOIN wallets'

subcommand_option_handling :normal
arguments :strict

desc 'Scans for unspent transactions in selected wallet(s) below the threshold'
arg_name '| Example of usage: bitvacuum scan -c BitCoin -t 0.0001'
command :scan do |c|
  c.desc 'Verbose. #Currently not implemented'
  c.switch [:v, :verbose]

  c.desc 'Specify currency (Bitcoin, Litecoin, Dogecoin, Darkcoin etc)'
  c.default_value 'all'
  c.arg_name '[CURRENCY NAME]'
  c.flag [:c, :currency]

  c.desc 'Maximum transaction amount'
  c.default_value YAML::load_file(File.join(__dir__, '../config/application.yml'))['input_value_threshold'] # TODO: To investigate why configuration method cannot be invoked here
  c.arg_name '[VALUE]'
  c.flag [:t, :threshold]

  c.action do |global_options, options, args|
    if options[:threshold]
      threshold = options[:threshold].to_f
    else
      threshold = config['input_value_threshold']
    end

    puts "Running scan with options: #{options}"
    puts '====='

    @operational_currencies.each do |currency|
      puts "Scanning for unspent transactions for currency: #{currency[:name]}"
      establish_connection(currency)
      unspent = scan_for_unspent_transactions(threshold)
      # TODO: To store results in database
      puts "Found #{unspent.count} unspent transactions."
      puts unspent
      puts 'Scan successful!'
    end

  end
end

desc 'Merge small inputs into bigger transactions'
command :run do |c|
  c.desc 'Specify currency (Bitcoin, Litecoin, Dogecoin, Darkcoin etc)'
  c.default_value 'all'
  c.arg_name '[CURRENCY NAME]'
  c.flag [:c, :currency]

  c.desc 'Maximum transaction amount'
  c.default_value YAML::load_file(File.join(__dir__, '../config/application.yml'))['input_value_threshold'] # TODO: To investigate why configuration method cannot be invoked here
  c.arg_name '[VALUE]'
  c.flag [:t, :threshold]

  c.desc 'Number of transactions to send'
  c.default_value YAML::load_file(File.join(__dir__, '../config/application.yml'))['transactions_to_send'] # TODO: To investigate why configuration method cannot be invoked here
  c.arg_name '[VALUE]'
  c.flag [:n, :transactions_to_send]

  c.desc 'Maximum transaction fee'
  c.default_value YAML::load_file(File.join(__dir__, '../config/application.yml'))['transaction_fee'] # TODO: To investigate why configuration method cannot be invoked here
  c.arg_name '[VALUE]'
  c.flag [:f, :fee]

  c.desc 'Maximum transaction size in bytes'
  c.default_value YAML::load_file(File.join(__dir__, '../config/application.yml'))['transaction_size'] # TODO: To investigate why configuration method cannot be invoked here
  c.arg_name '[VALUE]'
  c.flag [:s, :size]

  c.desc 'Minimum inputs to start cleaning'
  c.default_value YAML::load_file(File.join(__dir__, '../config/application.yml'))['inputs_to_start'] # TODO: To investigate why configuration method cannot be invoked here
  c.arg_name '[VALUE]'
  c.flag [:i, :inputs]

  c.action do |global_options, options, args|
    if options[:threshold]
      threshold = options[:threshold].to_f
    else
      threshold = config['input_value_threshold']
    end

    puts "Running scan with options: #{options}"
    puts '====='

    @operational_currencies.each do |currency|
      puts "Scanning for unspent transactions for currency: #{currency[:name]}"
      establish_connection(currency)
      unspent = scan_for_unspent_transactions(threshold)
      puts "Found #{unspent.count} unspent inputs."
      operational_inputs = unspent
      transaction_buffer = []
      configuration.param['transactions_to_send'].times do
        unless operational_inputs.nil?
          transaction_buffer = accumulate_inputs(operational_inputs)
        else
          puts 'Nothing to clean!'
        end
      end

    end
    # TODO: To store results in database
  end
end

pre do |global, command, options, args|
  @currencies = configuration.param['currencies']
  currency = options[:currency].downcase

  unless @currencies.include? currency or currency == 'all'
    raise "Unknown currency #{currency}"
  end

  load_currency_configuration currency
  true
end

post do |global, command, options, args|
  # Post logic here
  # Use skips_post before a command to skip this
  # block on that command only
end

on_error do |exception|
  puts "Error occured: #{exception.message}"
end

def scan_for_unspent_transactions(threshold)
  unspent = @connection.listunspent.select { |t| t['amount'] <= threshold }
  unspent.sort_by { |t| t['amount'] }
end

def accumulate_inputs(inputs)
  buffer = []
  while calculate_transaction_size(buffer) <= configuration.param['transaction_size'] && calculate_value_of_inputs(buffer) <= configuration.param['minimum_transaction_value'] || calculate_transaction_size(buffer) > configuration.param['transaction_size'] do
    if inputs.empty?
      raise 'No more inputs to process, transaction value is still not optimal' #TODO: Loop exit instead of raise
    end
    buffer = buffer.push(inputs.slice!(-1))
    if calculate_transaction_size(buffer) > configuration.param['transaction_size']
      if inputs.count < 2
        raise 'Inputs count is less than 2' #TODO: Loop exit instead of raise
      end
      puts 'Warning: Transaction size limit is exceeded, trying to change last two inputs to more valuable one !'
      inputs = inputs.push(buffer.slice!(-1, 2)).flatten
      buffer = buffer.slice!(-1, 2)
      buffer = buffer.push(inputs.slice!(0))
    end
    puts "Now transaction buffer is: #{buffer}"
    printf 'Transaction buffer value is: %f; ',calculate_value_of_inputs(buffer)
    puts "Transaction buffer size is: #{calculate_transaction_size(buffer)}"
  end

  buffer
end

def calculate_transaction_size(inputs)
  if inputs.empty?
    0
  else
    inputs.count * 180 + 34 + inputs.count
  end
end

def configuration
  Configuration.instance
end

def calculate_value_of_inputs(inputs)
  if inputs.empty?
    0
  else
    value = inputs.map { |i| i['amount'] }.reduce :+
    value
  end
end

def load_currency_configuration(currency_name)
  @operational_currencies = []
  wallets = configuration.wallets
  if currency_name == 'all'
    @currencies.each do |currency|
      @operational_currencies.push({name: currency, config: wallets[currency]})
    end
  else
    @operational_currencies.push({name: currency_name, config: wallets[currency_name]})
  end
end

def establish_connection(currency)
  @connection = Bitcoin::Client.new(currency[:config]['rpc_username'], currency[:config]['rpc_password'],
                                    :host => currency[:config]['rpc_host'], :port => currency[:config]['rpc_port'])
end

exit run(ARGV)
